{"name":"Zenn-la","tagline":"A REST microframework for Google App Engine (webapp2 and ndb)","body":"# Zenn-La\r\nA REST microframework for Google App Engine (webapp2 and ndb)\r\n\r\n##Contents\r\n* [Installation](#installation)\r\n* [Example Usage](#example-usage)\r\n* [Custom Serializers](#custom-serializers)\r\n* [Validations](#validations)\r\n* [ViewSets](#viewsets)\r\n* [Routers](#routers)\r\n* [Filtering](#filtering)\r\n* [Renderers](#renderers)\r\n\r\n## Installation:\r\nInstall using `pip`\r\n```\r\n$ pip install zennla\r\n```\r\nFor help with adding third party Python packages in Google App Engine, read [here](https://cloud.google.com/appengine/docs/python/tools/libraries27?hl=en)\r\n\r\n## Example Usage:\r\nSuppose you have a model named `Pokemon`:\r\n```python\r\nfrom google.appengine.ext import ndb\r\n\r\nclass Pokemon(ndb.Model):\r\n    name = ndb.StringProperty()\r\n    type = ndb.StringProperty()\r\n    number = ndb.IntegerProperty()\r\n```\r\n\r\nDefine a serializer for this model:\r\n```python\r\nfrom zennla.serializers import ModelSerializer\r\n\r\nclass PokemonSerializer(ModelSerializer):\r\n    model = Pokemon\r\n```\r\n\r\nDefine a viewset for this model:\r\n```python\r\nfrom zennla.viewsets import ModelViewSet\r\n\r\nclass PokemonViewSet(ModelViewSet):\r\n    serializer_class = PokemonSerializer\r\n    model = Pokemon  # Optional - uses serializer_class's `model` instance by default\r\n```\r\n\r\nAdd a route to your resource linking a base URL to the viewset:\r\n```python\r\nimport webapp2\r\nfrom zennla.routers import route\r\n\r\napp = webapp2.WSGIApplication([\r\n    route('/pokemon', PokemonViewSet)\r\n])\r\n```\r\n\r\n...and you have a working API for the `Pokemon` model! It supports GET and POST on `pokemon/` and GET, PUT, DELETE on `pokemon/<id>/` by default.\r\n\r\nYou can create a `Pokemon` object as:\r\n```\r\n{{base_url}}/pokemon/ [POST]\r\nBody:\r\n{\r\n    \"name\": \"Bulbasaur\",\r\n    \"type\": \"Grass\",\r\n    \"number\": 1\r\n}\r\n\r\nResponse (201):\r\n{\r\n    \"name\": \"Bulbasaur\",\r\n    \"type\": \"Grass\",\r\n    \"number\": 1,\r\n    \"id\": 4785074604081152\r\n}\r\n```\r\n\r\nYou can fetch your `Pokemon` resource as:\r\n```\r\n{{base_url}}/pokemon/ [GET]\r\n\r\nResponse (200):\r\n[\r\n    {\r\n        \"name\": \"Bulbasaur\",\r\n        \"type\": \"Grass\",\r\n        \"number\": 1,\r\n        \"id\": 4785074604081152\r\n    }\r\n]\r\n```\r\n\r\nOr retrieve a specific `Pokemon` as:\r\n```\r\n{{base_url}}/pokemon/4785074604081152/ [GET]\r\n\r\nResponse (200):\r\n{\r\n    \"name\": \"Bulbasaur\",\r\n    \"type\": \"Grass\",\r\n    \"number\": 1,\r\n    \"id\": 4785074604081152\r\n}\r\n```\r\n\r\nOr update a `Pokemon` as:\r\n```\r\n{{base_url}}/pokemon/4785074604081152/ [PUT]\r\n{\r\n    \"name\": \"Bulbasaur\",\r\n    \"type\": \"Grass/Poison\",\r\n    \"number\": 1\r\n}\r\n\r\nResponse (200):\r\n{\r\n    \"name\": \"Bulbasaur\",\r\n    \"type\": \"Grass/Poison\",\r\n    \"number\": 1,\r\n    \"id\": 4785074604081152\r\n}\r\n```\r\n\r\n\r\n\r\n## Custom Serializers\r\nYou can set the following attributes in the `ModelSerializer` subclass\r\n- `include_fields`: List of field names to be included in the serialized form of a model object.\r\n- `exclude_fields`: List of field names to be excluded in the serialized form of a model object. Takes precedence over `include_fields`\r\n- `translate_fields`: A dict mapping field names to the names used in serialized representation\r\n\r\nYou can override `to_dict_repr` method to define your own dictionary representation of a model object.\r\n\r\nYou can also add a method named as `get_<field_name>` to define a custom representation for that field.\r\n\r\nYou can add pre and post save hooks (methods that run just before and after an object is written to the datastore respectively) by defining `pre_save(self, instance, data, validated_data)` and `post_save(self, instance, data, validated_data)` respectively.\r\n\r\n### Example:\r\n```python\r\nclass PokemonSerializer(ModelSerializer):\r\n    model = Pokemon\r\n    include_fields = [\"name\", \"number\"]  # Only include these fields\r\n    translate_fields = {\r\n        \"number\": \"code\"  # Translate `number` to `code` in serialized representation\r\n    }\r\n\r\n    def get_name(obj):\r\n        return \"Pokemon \" + obj.name\r\n```\r\n\r\n```\r\n{{base_url}}/pokemon/ [GET]\r\n[\r\n    {\r\n        \"name\": \"Pokemon Bulbasaur\",\r\n        \"code\": 1\r\n    }\r\n]\r\n```\r\n\r\n\r\n## Validations\r\nThe `ModelSerializer` by default performs a validation for field type on the input data. In addition to that, you can add your own field validations. You can also perform object level validations.\r\nThe field validations should be methods in your `ModelSerializer` named as `validate_<field_name>`. The method should raise a `ValidationError` if the input field value is not valid, or return silently.\r\nYou can define any object level validations by defining the `validate(self, data, model)` method.\r\n\r\nThe validation flow is:\r\n- basic validations\r\n- field validations\r\n- object level validation\r\n\r\n### Example:\r\n```python\r\nfrom zennla.exceptions import ValidationError\r\n\r\nclass PokemonSerializer(ModelSerializer):\r\n    model = Pokemon\r\n\r\n    def validate_name(self, field_value):\r\n        \"\"\"\r\n        Only accept lower-case names\r\n        \"\"\"\r\n        if field_value != field_value.lower():\r\n            raise ValidationError(\"Name must be lower case!\")\r\n```\r\n\r\n```\r\n{{base_url}}/pokemon/ [POST]\r\n{\r\n    \"name\": \"Mewtwo\",\r\n    \"type\": \"Psychic\"\r\n    \"number\": 150\r\n}\r\n\r\nResponse (400):\r\n{\r\n    \"detail\": \"Name must be lower case!\"\r\n}\r\n```\r\n\r\n\r\n\r\n## Viewsets\r\nViewsets are request handler classes which provide CRUD operations.\r\nTo define custom viewsets, you can override `get()`, `put()`, `post()` and `delete()` or any other method corresponding to the allowed methods.\r\n\r\n### Customizing\r\n- You can also add pre and post method handler hooks to perform any actions. These should be defined as `pre_<handler_method>` or `post_<handler_method>`.\r\n\r\n- You can add filtering to the viewsets by listing the FilterSets in the `filter_backends` attribute (Discussed in detail [here](#filtering)).\r\n\r\n- You can support a number of media types by listing the renderers in the `renderers` attribute (Discussed in detail [here](#renderers))\r\n\r\n- Overriding `get_query()`: You can override `get_query()` to perform any filtering of the result set before serialization.\r\n\r\n- Overriding `get_serializer_class()`: You can override `get_serializer_class()` to choose a serializer class dynamically.\r\n\r\n- Overridding `get_model()`: You can override `get_model()` to choose a model dynamically. Defaults to the model defined by the `model` attribute or, if not defined, the `model` attribute of the `serializer_class`.\r\n\r\n### Example\r\n\r\n```python\r\nclass PokemonViewSet(ModelViewSet):\r\n    serializer_class = PokemonSerializer\r\n\r\n    def pre_get(self, *args, **kwargs):\r\n        # perform_some_action\r\n        return\r\n\r\n    def get_query():\r\n        \"\"\"\r\n        Only query on Grass type Pokemon\r\n        \"\"\"\r\n        return Pokemon.query(Pokemon.type == 'grass')\r\n```\r\n\r\n\r\n\r\n## Routers\r\nRouters provide routing mechanism for resources. It contains a `route()` function which returns a `routes.PathPrefixRoute` (read [here](https://webapp-improved.appspot.com/guide/routing.html#path-prefix-routes)) mapping a request handler `viewset` with a `base_url`.\r\n\r\nThe `viewset` must:\r\n- have `get()`, `post()`, `put()`, `delete()` defined\r\nor\r\n- extend `viewset.ModelViewSet`\r\n\r\nThe `routes.PathPrefixRoute` has two routes:\r\n- The list view at `base_url`/ with URI: `base_url`-list\r\n- The detail view at `base_url`/<id> with URL `base_url`-detail\r\n\r\nOptional Parameters:\r\n- `detail_field`: The name of the field used to identify a resource\r\n- `allowed_list_methods`: List of HTTP methods allowed for list view.\r\n        Default is [GET, POST]\r\n- `allowed_detail_methods`: List of HTTP methods allowed for\r\n        detail view. Default is [GET, PUT, DELETE]\r\n\r\n\r\n\r\n## Filtering\r\nYou can create filters by extending the `FilterSet` class. The `FilterSet` class lists all the filters that need to be applied to a query and contains a method `get_filtered_query()` which filters the query using the listed filters. The FilterSet must have an attribute whose name becomes a query parameter and value is equal to one of the `FieldFilter`s. The `FieldFilter`s defined by default are:\r\n\r\n- `NumberFilter`: Use this to make a filter that takes numeric values\r\n- `BooleanFilter`: Use this to make a filter that takes boolean values\r\n- `StringFilter`: Use this to make a filter that takes string values\r\n\r\nA `FilterField` needs to be specified an ndb model field on which it should be applied. It also has a `lookup_type` attribute which can be used to define the type of lookup. The valid values are:\r\n- `'eq'`: Check for equality (default)\r\n- `'in'`: Compare against a list of values\r\n- `'ne'`: Check for inequality\r\n- `'le'`: Check for less than or equals (<=)\r\n- `'ge'`: Check for greater than or equals (>=)\r\n- `'lt'`: Check for less than (<)\r\n- `'gt'`: Check for greater than (>)\r\n\r\nYou can create your own FilterFields by overriding `get_converted_value()` which takes in a raw value (string) and converts it into the format required before any comparisons are done.\r\n\r\n### Example\r\n```python\r\nfrom zennla import filters\r\n\r\nclass PokemonFilter(filters.FilterSet):\r\n    name = filters.StringFilter(Pokemon.name)\r\n    type = filters.StringFilter(Pokemon.type, lookup_type='in')\r\n    num_ge = filters.NumberFilter(Pokemon.number, lookup_type='ge')\r\n\r\nclass PokemonViewSet(ModelViewSet):\r\n    serializer_class = PokemonSerializer\r\n    filter_backends = [PokemonFilter]  # Add the filterset to our viewset\r\n\r\n```\r\n\r\n```\r\n{{base_url}}/pokemon/?name='Mewtwo'&type='Grass'&type='Psychic'&type='Electric'&num_ge=75 [GET]\r\n{\r\n    \"name\": \"Mewtwo\",\r\n    \"type\": \"Psychic\"\r\n    \"number\": 150\r\n}\r\n\r\nResponse (200):\r\n[\r\n    {\r\n        \"name\": \"Mewtwo\",\r\n        \"type\": \"Psychic\"\r\n        \"number\": 150\r\n    }\r\n]\r\n```\r\n\r\n\r\n\r\n## Renderers\r\nRenderers are used to serialize a response into specific media types. They give a generic way of being able to handle various media types on the response, such as JSON encoded data or HTML output.\r\n\r\nBy default Zenn-La provides a `JSONRenderer` and an `XMLRenderer`. You can define custom renderers by subclassing `BaseRenderer` and setting the `media_type` and `format` attributes, and overriding the `render()` method.\r\n\r\nThe renderer is chosen corresponding to the `Accept` header set on the request (read [here](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html)). If no satisfying renderer is found associated with the viewset, a `406 - Not Acceptable` response is returned. If no `Accept` header is set, the first renderer in the `renderers` list of the view set is used. By default, `ModelViewSet` uses `JSONRenderer`.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}